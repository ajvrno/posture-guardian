<!DOCTYPE html>
<html>
<head>
  <title>Posture Guardian</title>
  <link rel="stylesheet" type="text/css" href="style.css" />
</head>

<body>
  <div class="app-container">
    <h1>Posture Guardian üßç‚Äç‚ôÇÔ∏è</h1>
    <p class="description">
      Tired of looking like the Hunchback of Notredam? Don't fret! Posture Guardian is here to help.
      Get instant feedback to help you correct slouching and maintain a healthy posture!
    </p>

    <div class="video-wrapper">
      <video id="webcam" autoplay playsinline></video>
      <canvas id="canvas"></canvas>
      <div id="status-message" class="status-alert">Initializing.</div>
    </div>
  </div>

  <!-- MediaPipe libs -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>

  <script>
    const video = document.getElementById('webcam');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const statusMessage = document.getElementById('status-message');

    const pose = new Pose({
      locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`
    });

    pose.setOptions({
      modelComplexity: 0,
      smoothLandmarks: true,
      enableSegmentation: false,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    let previousLandmarks = null;

    function smoothLandmarks(current, previous, factor = 0.6) {
      if (!previous) return current;
      return current.map((pt, i) => ({
        x: pt.x * factor + previous[i].x * (1 - factor),
        y: pt.y * factor + previous[i].y * (1 - factor),
        z: pt.z * factor + previous[i].z * (1 - factor)
      }));
    }

    function getAngle(A, B, C) {
      const AB = { x: B.x - A.x, y: B.y - A.y };
      const CB = { x: B.x - C.x, y: B.y - C.y };
      const dot = AB.x * CB.x + AB.y * CB.y;
      const magAB = Math.hypot(AB.x, AB.y);
      const magCB = Math.hypot(CB.x, CB.y);
      return Math.acos(dot / (magAB * magCB)) * (180 / Math.PI);
    }

    pose.onResults(results => {
      if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
      }

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!results.poseLandmarks) {
        statusMessage.textContent = "Waiting for user.";
        statusMessage.className = 'status-alert waiting';
        return;
      }

      const lm = smoothLandmarks(results.poseLandmarks, previousLandmarks);
      previousLandmarks = lm;

      const leftShoulder = lm[11], rightShoulder = lm[12];
      const leftHip = lm[23], rightHip = lm[24];
      const leftEar = lm[7], rightEar = lm[8];
      const nose = lm[0];

      const avgShoulder = {
        x: (leftShoulder.x + rightShoulder.x) / 2,
        y: (leftShoulder.y + rightShoulder.y) / 2
      };
      const avgHip = {
        x: (leftHip.x + rightHip.x) / 2,
        y: (leftHip.y + rightHip.y) / 2
      };
      const avgEar = {
        x: (leftEar.x + rightEar.x) / 2,
        y: (leftEar.y + rightEar.y) / 2
      };

      // Metrics
      const torsoAngle = getAngle(avgHip, avgShoulder, nose);
      const headOffset = Math.abs(nose.x - avgShoulder.x);
      const shoulderRoll = Math.abs(leftShoulder.y - rightShoulder.y);
      const lateralPelvisShift = Math.abs(avgShoulder.x - avgHip.x);
      const headDrop = avgShoulder.y - avgEar.y;

      const isSlouching =
        torsoAngle < 35 ||
        headOffset > 0.15 ||
        shoulderRoll > 0.1 ||
        lateralPelvisShift > 0.08 ||
        headDrop < 0.25;

      if (typeof window.lastSlouchState === 'undefined') {
        window.lastSlouchState = false;
        window.slouchHoldFrames = 0;
      }

      if (isSlouching) {
        window.lastSlouchState = true;
        window.slouchHoldFrames = 0;
      } else if (window.lastSlouchState) {
        window.slouchHoldFrames++;
        if (window.slouchHoldFrames > 30) { 
          window.lastSlouchState = false;
          window.slouchHoldFrames = 0;
        }
      }

      // Update the on-page chip
      if (window.lastSlouchState) {
        statusMessage.textContent = "You're slouching! Sit up straight!";
        statusMessage.className = 'status-alert slouch';
      } else {
        statusMessage.textContent = "Good posture üëç";
        statusMessage.className = 'status-alert good';
      }

      (function () {
        const title = window.lastSlouchState ? 'Posture Alert' : 'Posture';
        const message = window.lastSlouchState
          ? "You're slouching! Sit up straight!"
          : "Good posture üëç";
        try {
          window.postMessage({
            type: 'PG_ALERT',
            payload: { isSlouch: window.lastSlouchState, title, message }
          }, '*');
        } catch (e) { /* no-op */ }
      })();

      // Draw markers
      const drawDot = (pt, color = "#FF3D00") => {
        ctx.beginPath();
        ctx.fillStyle = color;
        ctx.arc(pt.x * canvas.width, pt.y * canvas.height, 4, 0, 2 * Math.PI);
        ctx.fill();
      };

      [leftShoulder, rightShoulder, leftHip, rightHip, leftEar, rightEar, nose].forEach(pt => drawDot(pt));

      ctx.strokeStyle = "#00FF00";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(leftShoulder.x * canvas.width, leftShoulder.y * canvas.height);
      ctx.lineTo(rightShoulder.x * canvas.width, rightShoulder.y * canvas.height);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(avgShoulder.x * canvas.width, avgShoulder.y * canvas.height);
      ctx.lineTo(avgHip.x * canvas.width, avgHip.y * canvas.height);
      ctx.stroke();
    });

    const camera = new Camera(video, {
      onFrame: async () => {
        await pose.send({ image: video });
      },
      width: 640,
      height: 480
    });

    camera.start();
  </script>
</body>
</html>
